#include "mesh.h"
mesh_t* load_mesh_from_file(const char* filename, vec4f_t color) {
    mesh_t* mesh = calloc(1, sizeof(mesh_t));
    
    FILE* file = fopen(filename, "r");
    if (!file) {
        engine_log("MESH", "Could not open file", ERROR);
        free(mesh);
        return NULL;
    }
    
    // First pass: count elements
    char line[256];
    int vertex_count = 0;
    int index_count = 0; // Total indices needed (3 per triangle)
    
    while (fgets(line, sizeof(line), file)) {
        if (line[0] == 'v' && line[1] == ' ') {
            vertex_count++;
        }
        else if (line[0] == 'f') {
            // Quick count of vertices in face
            int vertices_in_face = 0;
            for (char* p = line + 2; *p; p++) {
                if (*p == ' ') vertices_in_face++;
            }
            vertices_in_face++; // Last vertex
            
            // Convert to triangles: (n-2) triangles * 3 indices
            if (vertices_in_face >= 3) {
                index_count += (vertices_in_face - 2) * 3;
            }
        }
    }
    
    rewind(file);
    
    // Allocate memory
    mesh->positions = calloc(vertex_count, sizeof(vec4f_t));
    mesh->colors = calloc(vertex_count, sizeof(vec4f_t));
    mesh->indices = calloc(index_count, sizeof(uint32_t));
    mesh->count = vertex_count;
    
    // Parse vertices
    vec4f_t* positions = mesh->positions;
    int v_idx = 0;
    
    while (fgets(line, sizeof(line), file)) {
        if (line[0] == 'v' && line[1] == ' ') {
            float x, y, z;
            if (sscanf(line, "v %f %f %f", &x, &y, &z) == 3) {
                positions[v_idx++] = (vec4f_t){x, y, z, 1.0f};
            }
        }
    }
    
    rewind(file); // Rewind to parse faces
    
    // Parse faces and generate indices
    uint32_t* indices = mesh->indices;
    int idx_idx = 0;
    
    while (fgets(line, sizeof(line), file)) {
        if (line[0] == 'f') {
            // Extract vertex indices
            int face_vertices[64];
            int face_count = 0;
            
            char* token = strtok(line + 2, " \n");
            while (token && face_count < 64) {
                // Extract just the vertex index (before any '/')
                int v;
                if (sscanf(token, "%d", &v) == 1) {
                    // Convert to 0-based
                    if (v > 0) v--;
                    else if (v < 0) v = vertex_count + v;
                    
                    if (v >= 0 && v < vertex_count) {
                        face_vertices[face_count++] = v;
                    }
                }
                token = strtok(NULL, " \n");
            }
            
            // Triangulate (triangle fan)
            if (face_count >= 3) {
                int v0 = face_vertices[0];
                for (int i = 1; i < face_count - 1; i++) {
                    indices[idx_idx++] = v0;
                    indices[idx_idx++] = face_vertices[i];
                    indices[idx_idx++] = face_vertices[i + 1];
                }
            }
        }
    }
    
    fclose(file);
    
    // Set index count
    mesh->index_count = idx_idx;
    
    // Apply color to all vertices
    for (int i = 0; i < vertex_count; i++) {
        mesh->colors[i] = color;
    }
    
    return mesh;
}

mesh_t* load_mesh_from_file(const char* filename, vec4f_t color){
  mesh_t* mesh = calloc(1, sizeof(mesh_t));

  FILE* file = fopen(filename, "r");
  if (!file){
    engine_log("MESH", "Could not open file", ERROR);
    return NULL;
  }

  //counting elements
  char line[256];
  int vertex_count = 0, face_count = 0;
  while (fgets(line, sizeof(line), file)){
    if (line[0] == 'v'){
      if (line[1] == ' ') vertex_count++;
    }
    else if (line[0] == 'f'){
      face_count++;
    }
  }
  rewind(file);

  //alocating memory to store mesh attributes
  mesh->positions = calloc(vertex_count, sizeof(vec4f_t));
  mesh->colors = calloc(vertex_count, sizeof(vec4f_t));
  mesh->indices = calloc(face_count * 3, sizeof(uint32_t));
  mesh->count = vertex_count;
 
  //parsing the data
  int vertex_i = 0;
  int index_i = 0;
  while(fgets(line, sizeof(line), file)){
    //skip useless stuf for now
    if (line[0] == '#' || line[0] == '\n'){
      continue;
    }
    //case vertex
    if (line[0] == 'v' && line[1] == ' '){
      float x, y, z;
      sscanf(line, "v %f %f %f", &x, &y, &z);
      mesh->positions[vertex_i] = (vec4f_t){x, y, z, 1.f};
      mesh->colors[vertex_i] = make_random_vec4f();
      vertex_i++;
    }
    //case face
    else if (line[0] == 'f'){
      int vertex_indices[10]; 
      int texture_indices[10]; 
      int normal_indices[10]; 
      int num_vertices = 0;
      
      char* token = strtok(line + 2, " \n");
      while (token && num_vertices < 10) {
        if (sscanf(token, "%d/%d/%d",
                   &vertex_indices[num_vertices],
                   &texture_indices[num_vertices],
                   &normal_indices[num_vertices]) == 3){
          
        }
      }
      int v1, v2, v3; 
      if (sscanf(line, "f %d/%*d/%*d %d/%*d/%*d %d/%*d/%*d", &v1, &v2, &v3) == 3 ||
          sscanf(line, "f %d//%*d %d//%*d %d//%*d", &v1, &v2, &v3) == 3 ||
          sscanf(line, "f %d %d %d", &v1, &v2, &v3) == 3){
        //OBJ indices are 1 based so -1 to convert to C-style indexing
        mesh->indices[index_i++] = v1 - 1;
        mesh->indices[index_i++] = v2 - 1;
        mesh->indices[index_i++] = v3 - 1;
      }
    }
  }

  fclose(file);
  
  return mesh;
}

void free_mesh(mesh_t* mesh){
  if (!mesh || !mesh->positions || !mesh->colors || !mesh->indices){
    engine_log("MESH", "Invalid mesh pointer during free_mesh", ERROR);
    return;
  }
  
  free(mesh->positions);
  free(mesh->colors);
  free(mesh->indices);
  free(mesh);
}
